---
title: "Classification"
output: html_document
---

```{r setup, include=FALSE}
library(mosaic)
options(digits = 6)
library(rpart) # for classification trees
library(class) # for kNN methods
library(randomForest) # for random forests
library(GGally)
library(partykit)
library(gbm)
library(e1071) #may need to be installed
```

Our best method is going to end up being the random forest approach

##Preliminary Analysis

```{r}
dim(reducedGroupData)
tally(~ Class, data = reducedGroupData, format = "count")
#ggpairs(reducedGroupData, columns = 1:9, ggplot2::aes(color = Class))
```


```{r, eval = FALSE}
set.seed(220)
sampleData <- reducedGroupData[ , sample(ncol(reducedGroupData)-1, 25)]
protein_matrix<- data.matrix(reducedGroupData)
protein_heatmap <- heatmap(protein_matrix, Rowv=NA, Colv=NA, col = cm.colors(256), scale="column")
```


## Tree Method

#Best tree we could create
```{r,fig.height = 7, eval=FALSE}
g.control <- rpart.control(minsplit = 10, minbucket = 5, xval = 0)
g.treeorig <- rpart(Class ~ ., data = reducedGroupData, method = "class", control = g.control)
plot(g.treeorig)
text(g.treeorig, cex = 0.7)
printcp(g.treeorig)
#summary(g.treeorig) #only turn on if you really want it
```

## This is the same tree but running a jacknife cross validation approach
```{r, fig.height = 7, eval=TRUE}
g.control2 <- rpart.control(minsplit = 10, minbucket = 5, xval = 801)
g.treeorig2 <- rpart(Class ~ ., data =reducedGroupData , method = "class", control = g.control2)
printcp(g.treeorig2)
plotcp(g.treeorig2)
plot(g.treeorig2)
text(g.treeorig2, cex = 0.7)
```

#Same tree but running a 10 fold cross validation
```{r, fig.height = 7, eval=TRUE}
g.control2 <- rpart.control(minsplit = 10, minbucket = 5, xval = 10)
g.treeorig2 <- rpart(Class ~ ., data =reducedGroupData , method = "class", control = g.control2)
printcp(g.treeorig2)
plotcp(g.treeorig2)
plot(g.treeorig2)
text(g.treeorig2, cex = 0.7)
```



#Random Forest Section

-This ends up being our best method based on the TER and AER

```{r}
set.seed(240)
cancerRandomForest <- randomForest(Class ~ ., data = reducedGroupData, mtry = 10, ntree = 100, importance = T, proximity = T)
cancerRandomForest
table(reducedGroupData$Class, predict(cancerRandomForest, groupddata))
```


##Boosting Procedure

##Create Holdout Samples from Data Set
```{r}
#setup
set.seed(240)
group_train <- reducedGroupData %>% sample_frac(0.75) 
tally(~ Class, group_train)
group_test <- reducedGroupData %>% setdiff(group_train)
tally(~Class, data=group_test)
```

##This is to get AER
```{r}
set.seed(240)
group.boost2 <- gbm(Class ~ ., data = group_train, distribution = "multinomial", 
                   n.trees = 5000, interaction.depth = 3, shrinkage = 0.1)
summary(group.boost)
boost_estimate2 <- predict(group.boost, newdata = group_train, 
                         n.trees = 5000, type = "response")
pred_group2 <- apply(boost_estimate2, 1, which.max)
tally(~ pred_group2)
table(group_train$Class, pred_group2)
```


##To get TER
```{r}
set.seed(240)
group.boost <- gbm(Class ~ ., data = group_train, distribution = "multinomial", 
                   n.trees = 5000, interaction.depth = 3, shrinkage = 0.1)
summary(group.boost)
boost_estimate <- predict(group.boost, newdata = group_test, 
                         n.trees = 5000, type = "response")
pred_group <- apply(boost_estimate, 1, which.max)
tally(~ pred_group)
table(group_test$Class, pred_group)
```
```{r}
round(relative.influence(group.boost, n.trees=5000), 2 )
```



#KNN approach

##To get AER
```{r}
##This is to get AER
g.knn <- knn(group_train[,-56], group_train[,-56], group_train$Class, k = 4, prob = T)
table(group_train$Class, g.knn)
temptable <-table(group_train$Class, g.knn)
tempsum <- as.numeric(sum(as.matrix(temptable)) - sum(diag(as.matrix(temptable))))
tempsum/(sum(as.matrix(temptable)))

```

##To get TER 

```{r}
##This is to get TER
g.knn <- knn(group_train[,-56], group_test[,-56], group_train$Class, k = 4, prob = T)
table(group_test$Class, g.knn)
temptable <-table(group_test$Class, g.knn)
tempsum <- as.numeric(sum(as.matrix(temptable)) - sum(diag(as.matrix(temptable))))
tempsum/(sum(as.matrix(temptable)))

```





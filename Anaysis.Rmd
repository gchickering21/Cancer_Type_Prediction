---
title: "Analysis"
author: "Group D"
date: "4/22/2019"
output: pdf_document
---

# Preliminary Analysis

The last column of the dataset (20533) is named "Class" - this is what we are trying to find

Columns 2:20532 are genes

```{r}
head(groupddata)
unique(groupddata$Class)
```


*** This takes about 10 minutes to run! ***

```{r, cache = TRUE}
pvals <- rep(1, 20530)

for(i in 1:20530){
  if(i %% 5000 == 0){
    print(i)
  }
  s <- i + 1
  pvals[i] <- anova(lm(groupddata[, s] ~ Class, data = groupddata))$"Pr(>F)"[1]
} #find all ANOVA p-values

#adjust for multiple testing
holmp <- p.adjust(pvals, method = "bonf")
length(which(holmp == 0))

#which ones are < 0.05 (for example)
myvars <- which(holmp == 0) + 1 #add one because MouseNum is at the start and was skipped

reducedGroupData <- groupddata[, c(1, myvars, 20533)]

ggplot(reducedGroupData) + geom_density(aes(x = gene_7421, color = Class))
ggplot(reducedGroupData) + geom_density(aes(x = gene_203, color = Class))
ggplot(reducedGroupData) + geom_density(aes(x = gene_5829, color = Class))
ggplot(reducedGroupData) + geom_density(aes(x = gene_16259, color = Class))
ggplot(reducedGroupData) + geom_density(aes(x = gene_19159, color = Class))

```


 [1] "X1"         "gene_18"    "gene_203"   "gene_219"   "gene_220"   "gene_450"   "gene_1510"  "gene_1858"  "gene_2037" 
[10] "gene_2288"  "gene_3439"  "gene_3461"  "gene_3523"  "gene_3737"  "gene_3921"  "gene_5829"  "gene_6733"  "gene_7116" 
[19] "gene_7238"  "gene_7421"  "gene_7896"  "gene_7964"  "gene_7965"  "gene_9175"  "gene_9176"  "gene_9626"  "gene_11059"
[28] "gene_11566" "gene_11903" "gene_12078" "gene_12808" "gene_12847" "gene_12848" "gene_12995" "gene_13210" "gene_13818"
[37] "gene_13976" "gene_14114" "gene_14503" "gene_15894" "gene_15895" "gene_15896" "gene_15898" "gene_16130" "gene_16132"
[46] "gene_16169" "gene_16246" "gene_16259" "gene_16337" "gene_16342" "gene_16358" "gene_16392" "gene_18135" "gene_19153"
[55] "gene_19159" "gene_19236" "Class"  


Clustering Analysis - 

Hierachical 

Single Linkage  - 

```{r}
gene.dist <- dist(reducedGroupData[, -c(1, 57)])
```

```{r}
hcsingle <- hclust(gene.dist, method = "single")
list(hcsingle)
plot(hcsingle)
```

```{r}
singleSol<- (cutree(hcsingle, k = 5))
summary(as.factor(singleSol))
```


```{r}
tally(singleSol ~ Class, format = "count", data = reducedGroupData)
```


```{r}
singlePCA <- princomp(reducedGroupData[, -c(1,57)], cor = TRUE)
plot(singlePCA$scores[, 1:2], type = "n", xlab = "PC1", ylab = "PC2", main = "Single Five cluster solution") #blank!
text(singlePCA$scores[, 1:2], labels = singleSol, cex = 0.6)
singlePCA$loadings[, 1:2]
```
Problems with single include that it tends to have long stringy clusters, as shown here. This is a classic example of chaining. However, single linkage is helpful in finding extreme outliers. 


Complete linkage - 

```{r}
hccomp <- hclust(gene.dist, method = "complete")
list(hccomp)
plot(hccomp)
```

```{r}
compSol<- (cutree(hccomp, k = 5))
summary(as.factor(compSol))
```

```{r}
tally(compSol ~ Class, format = "count", data = reducedGroupData)
```

Complete looks much better than single linkage. Clusters well spread out. Complete linkage gives clustrers of similar diameter. Hence, this solution looks better than the single linkage. 

```{r}
compPCA <- princomp(reducedGroupData[, -c(1,57)], cor = TRUE)
plot(compPCA$scores[, 1:2], type = "n", xlab = "PC1", ylab = "PC2", main = "Complete Linkage's Five cluster solution") #blank!
text(compPCA$scores[, 1:2], labels = compSol, cex = 0.6)
compPCA$loadings[, 1:2]
```

Average Linkage - 
```{r}
hcavg <- hclust(gene.dist, method = "average")
list(hcavg)
plot(hcavg)
```


```{r}
avgSol<- (cutree(hcavg, k = 5))
summary(as.factor(avgSol))
```


```{r}
tally(avgSol ~ Class, format = "count", data = reducedGroupData)
```
Compromise between average and single linkage. Cluster 3 is shockingly very small. 

Wards Solution - 

```{r}
hcward <- hclust(gene.dist, method = "ward.D")
list(hcward)
plot(hcward)
```

```{r}
wardSol<- (cutree(hcward, k = 5))
summary(as.factor(wardSol))
```
Very similar to the complete limkage solution. Only differs in clusters 2 and 3 because this method also tends to produce equal sized clusters. (Joins based on smallest within cluster sum of squares.)

```{r}
tally(wardSol ~ Class, format = "count", data = reducedGroupData)
```


```{r}
wardPCA <- princomp(reducedGroupData[, -c(1,57)], cor = TRUE)
plot(wardPCA$scores[, 1:2], type = "n", xlab = "PC1", ylab = "PC2", main = "Ward's Five cluster solution") #blank!
text(wardPCA$scores[, 1:2], labels = wardSol, cex = 0.6)
wardPCA$loadings[, 1:2]
```





K means - 

```{r}
wss <- rep(0, 12) #creates 8 copies of 0 to create an empty vector
for(i in 1:12){wss[i] <- sum(kmeans(scale(reducedGroupData[, -c(1,57)]), centers = i)$withinss)}                   
plot(1:12, wss, type = "b", xlab = "Number of groups", ylab = "Within groups sum of squares")
```

We know that there are five classes, however looking for an elbow in the scree plot above we would like to see solutions based on 3 or 6 clusters. 


```{r}
Ksol1 <- kmeans(scale(reducedGroupData[, -c(1,57)]), centers = 5) #centers is the # of clusters
#list(Ksol1) #so you can see what it gives you
Ksol1$centers
```

```{r}
tally(Ksol1$cluster ~ Class, data = reducedGroupData, format = "count")
```

```{r}
tally(Ksol1$cluster ~ wardSol, format = "count")
```3